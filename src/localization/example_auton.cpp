#include "localization/localization_manager.hpp"
#include "localization/ramsete.hpp"
#include "localization/robot_ports.hpp"
#include "localization/trajectory.hpp"
#include "main.h"
#include <memory>

using namespace localization;

/**
 * @brief Example of how to integrate the localization library into a PROS
 * project.
 */
void example_autonomous() {
  // 1. Hardware Initialization
  // Use the ports and geometry defined in robot_geometry.cpp
  pros::MotorGroup left_motors({(std::int8_t)DEFAULT_PORTS.leftDrivePort},
                               pros::v5::MotorGears::blue);
  pros::MotorGroup right_motors({(std::int8_t)DEFAULT_PORTS.rightDrivePort},
                                pros::v5::MotorGears::blue);
  pros::Imu imu(DEFAULT_PORTS.imuPort);
  pros::Distance distance_sensor(DEFAULT_PORTS.distanceSensorPort);

  // 2. Component Initialization
  auto odometry = std::make_shared<DifferentialOdometry>(
      &left_motors, &right_motors, &imu, DEFAULT_GEOMETRY);
  auto mcl = std::make_shared<MCLLocalizer>(200);
  auto manager =
      std::make_unique<LocalizationManager>(odometry, mcl, DEFAULT_GEOMETRY);

  // 3. Define the Field Map (12ft x 12ft VEX field)
  FieldMap field;
  field.walls = {
      {0, 0, 144, 0},     // Bottom wall
      {144, 0, 144, 144}, // Right wall
      {144, 144, 0, 144}, // Top wall
      {0, 144, 0, 0}      // Left wall
  };

  // 4. Initial Pose Setup
  Pose2D startPose = {24.0, 24.0, 0.0};
  manager->resetPose(startPose);

  // 5. Create a simple trajectory
  // In a real scenario, this would be loaded from a file or generated by a path
  // planner.
  std::vector<TrajectoryPoint> points = {
      {0.0, {24.0, 24.0, 0.0}, 0.0, 0.0},
      {1.0, {48.0, 24.0, 0.0}, 24.0, 0.0},
      {2.0, {72.0, 48.0, M_PI / 2}, 24.0, M_PI / 4}};
  Trajectory trajectory(points);
  RamseteController controller(2.0, 0.7);

  // 6. Main Autonomous Loop
  uint32_t startTime = pros::millis();
  double dt = 0.01; // 10ms loop

  while (true) {
    double currentTime = (pros::millis() - startTime) / 1000.0;
    if (currentTime > trajectory.getDuration())
      break;

    // Update localization
    manager->update(dt);

    // Periodically update with distance sensor if reading is valid
    double dist = distance_sensor.get_distance() / 25.4; // Convert mm to inches
    if (dist > 1.0 && dist < 80.0) {
      manager->sensorUpdate(dist, field);
    }

    // Get current fused pose
    Pose2D currentPose = manager->getFusedPose();

    // Sample trajectory and compute RAMSETE control
    TrajectoryPoint target = trajectory.sample(currentTime);
    ChassisSpeeds speeds =
        controller.computeControl(currentPose, target.pose, target.v, target.w);

    // Convert speeds (v, w) to wheel velocities
    // v = (vr + vl) / 2, w = (vr - vl) / trackWidth
    double vl = speeds.v - (speeds.w * DEFAULT_GEOMETRY.trackWidth / 2.0);
    double vr = speeds.v + (speeds.w * DEFAULT_GEOMETRY.trackWidth / 2.0);

    // Command motors (simple velocity control)
    // Convert inches/sec to RPM
    // RPM = (v / (2 * PI * radius)) * 60
    double leftRPM = (vl / (2 * M_PI * DEFAULT_GEOMETRY.wheelRadius)) * 60.0;
    double rightRPM = (vr / (2 * M_PI * DEFAULT_GEOMETRY.wheelRadius)) * 60.0;

    left_motors.move_velocity(leftRPM);
    right_motors.move_velocity(rightRPM);

    pros::delay(dt * 1000);
  }

  left_motors.brake();
  right_motors.brake();
}
